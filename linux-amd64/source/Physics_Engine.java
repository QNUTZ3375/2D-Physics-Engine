/* autogenerated by Processing revision 1293 on 2024-04-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.Arrays;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Physics_Engine extends PApplet {


float xForce = 100;
float yForce = 100;
int[] colors = {color(79, 77, 191), color(16, 213, 228), color(236, 124, 38), color(40, 230, 125), color(62, 240, 90),
                  color(250, 210, 1), color(133, 85, 171), color(149, 25, 185), color(86, 242, 28), color(2, 208, 221),
                  color(239, 202, 146), color(186, 116, 216), color(92, 168, 255), color(215, 240, 178), color(255, 47, 0),
                  color(230, 95, 202), color(109, 48, 21), color(155, 236, 181), color(245, 49, 200), color(55, 142, 28),
                  color(246, 255, 0), color(0, 251, 255), color(0, 255, 51), color(0, 255, 255), color(59, 255, 0)};
Shape[] objects;
PVector tangent = new PVector(0, 0);
PVector normal = new PVector(0, 0);
PVector direction = new PVector(0, 0);
PVector[] impulseList = {new PVector(0, 0), new PVector(0, 0)};
PVector[] frictionImpulseList = {new PVector(0, 0), new PVector(0, 0)};
float[] jList = {0.0f, 0.0f};
PVector[] raList = {new PVector(0, 0), new PVector(0, 0)};
PVector[] rbList = {new PVector(0, 0), new PVector(0, 0)};
PVector[] contactPointsArr = {new PVector(0, 0), new PVector(0, 0)};
float magnitude = 0;
float updateTime = 1/frameRate;
float gravity = 9.81f;
boolean gravityMode = true;
int wallThickness = 30;
float circleRadius = 30;
float squareSide = pow((circleRadius * circleRadius * PI), 0.5f);
int iterations = 20;
boolean collisionState = false;
int[][] contactPairsList = {};
//used for performance measurement
PFont metricsDisplay;
float currTimer = 0;
long stepTimer = 0; //counts the number of milliseconds between each update
float currUpdateTime = 0;
float currSampleCount = 0;
String stepTimerString = "0.0";

public float lengthOfVector(PVector a){
  if(abs(a.x) == 0.0f){
    return a.y;
  }
  if(abs(a.y) == 0.0f){
    return a.x;
  }
  return pow(a.x * a.x + a.y * a.y, 0.5f);
}

public float lengthOfVectorSquared(PVector a){
  return a.x * a.x + a.y * a.y;
}

public float lengthSquared(float a, float b){
  return a * a + b * b;
}

public float crossProduct(PVector a, PVector b){
  return a.x * b.y - a.y * b.x;
}

public float dotProduct(PVector a, PVector b){
  return a.x * b.x + a.y * b.y;
}

public float dotProductFloats(float ax, float ay, float bx, float by){
  return ax * bx + ay * by;
}

public boolean intersectingAABBs(PVector[] shapeA, PVector[] shapeB){
  //conditions for intersecting AABBs:
  //(L1 <= R2 && L2 <= R1) && (B1 >= T2 && B2 >= T1) 
  //it would usually be B1 <= T2 && B2 <= T1, but that only works if y increases upwards. So if y increases downwards, flip the comparisons

  //checks if any max value is less than any min value
  return (shapeA[0].x <= shapeB[1].x && shapeB[0].x <= shapeA[1].x && shapeA[1].y >= shapeB[0].y && shapeB[1].y >= shapeA[0].y); 
}

public PVector[] getAABB(Shape shape){
  //res stores top left and bottom right coordinates for each shape
  PVector res[] = new PVector[2];
  
  //gets the max and min vectors
  if(shape.shapeType == "Circle"){
    res[0] = new PVector(shape.center.x - shape.r, shape.center.y - shape.r);
    res[1] = new PVector(shape.center.x + shape.r, shape.center.y + shape.r);
  }else if(shape.shapeType == "Box"){
    PVector minVal = new PVector(pow(2, 31) - 1, pow(2, 31) - 1);
    PVector maxVal = new PVector(-1 * pow(2, 31), -1 * pow(2, 31));
    
    for(int i = 0; i < shape.vertices.length; i++){
      if(maxVal.x < shape.transformedVertices[i].x){
        maxVal.x = shape.transformedVertices[i].x;
      }
      if(maxVal.y < shape.transformedVertices[i].y){
        maxVal.y = shape.transformedVertices[i].y;
      }
      if(minVal.x > shape.transformedVertices[i].x){
        minVal.x = shape.transformedVertices[i].x;
      }
      if(minVal.y > shape.transformedVertices[i].y){
        minVal.y = shape.transformedVertices[i].y;
      }
    }
    
    res[0] = minVal; //Top Left
    res[1] = maxVal; //Bottom Right
  }
  return res;
}

public boolean outOfBounds(Shape shape){
  //gets the AABB of the current shape (min[0] and max[1] points for the x and y coordinates)
  PVector[] currAABB = getAABB(shape);
  //checks the leftmost point, rightmost point, and topmost point
  return (currAABB[0].x >= width) || (currAABB[1].x <= 0) || (currAABB[0].y >= height);
}

public void resetAndUpdateBodies(){
  //resets each object and moves it accordingly from the last update
  for(int i = 0; i < objects.length; i++){
    //skips static objects
    if(!objects[i].isMovable){
      continue;
    }
    ///gets the AABB for non-static objects
    objects[i].currAABB = getAABB(objects[i]);
    objects[i].getTransformedVertices();
        
    //checks if the object is still moving
    if(objects[i].force.x != 0 || objects[i].force.y != 0 || gravityMode == true){
      objects[i].updateForceVelocityAngle(updateTime, iterations);
    }
    //removes objects that are out of bounds
    if(outOfBounds(objects[i])){
      for(int j = i; j < objects.length - 1; j++){
        objects[j] = objects[j + 1];
      }
      objects = Arrays.copyOf(objects, objects.length - 1);
    }
  }
}

public void setup(){
  /* size commented out by preprocessor */;
  stroke(250);
  strokeWeight(2);
  metricsDisplay = createFont("Helvetica", 20, true);
  textFont(metricsDisplay, 20);
  rectMode(CENTER);
  
  objects = new Shape[3];
  
  //float x, float y, color c, boolean movable, float re, float radius, float width_, float height_, String type
  //bottom floor
  objects[0] = new Shape(width/2, height - wallThickness * 3, color(0, 150, 0), false, 0.5f, 0, width - wallThickness * 4, wallThickness, "Box");
  objects[0].currAABB = getAABB(objects[0]);
  //left slope
  objects[1] = new Shape(300, 450, color(150, 0, 0), false, 0.5f, 0, wallThickness * 16, wallThickness, "Box");
  objects[1].turn(20);
  objects[1].getTransformedVertices();
  objects[1].currAABB = getAABB(objects[1]);
  //right slope
  objects[2] = new Shape(700, 200, color(150, 150, 150), false, 0.5f, 0, wallThickness * 16, wallThickness, "Box");
  objects[2].turn(-20);
  objects[2].getTransformedVertices();
  objects[2].currAABB = getAABB(objects[2]);
}

public void draw(){
  background(170, 225, 225);
  //used for performance measurement
  currTimer++;
  if(currTimer >= frameRate){  
    stepTimerString = str(currUpdateTime/currSampleCount);
    currSampleCount = 0;
    currUpdateTime = 0;
    currTimer = 0;
  }
  
  stepTimer = millis();

  //goes through iterations (the iterations chop up big movements into smaller ones)
  for(int it = 0; it < iterations; it++){
    
    resetAndUpdateBodies();
    
    //resets the lists of contacts every cycle
    contactPairsList = Arrays.copyOf(contactPairsList, 0);
    
    findPotentialCollisions();
    checkPotentialCollisions();
  }
  
  //shows and updates all objects within the space
  for(int i = 0; i < objects.length; i++){
    objects[i].show();
    objects[i].update();
  }
  
  //used for measuring performance
  stepTimer = millis() - stepTimer;
  currUpdateTime += stepTimer;
  currSampleCount++;
  fill(0);
  text("Body Count: " + objects.length, 20, height - 20);
  text("World Step Time: " + stepTimerString + "ms", 20, height - 50);
}


public void keyPressed(){
  if(key == '1'){
    float w = random(squareSide * 3/4, squareSide * 3/2);
    float h = random(squareSide * 3/4, squareSide * 3/2);
    objects = Arrays.copyOf(objects, objects.length + 1);
    objects[objects.length - 1] = new Shape(mouseX, mouseY, colors[PApplet.parseInt(random(colors.length))], true, 0.5f, 0, w, h, "Box");
    objects[objects.length - 1].currAABB = getAABB(objects[objects.length - 1]);
  }
  if(key == '2'){
    float r = random(circleRadius * 3/4, circleRadius * 3/2);
    objects = Arrays.copyOf(objects, objects.length + 1);
    objects[objects.length - 1] = new Shape(mouseX, mouseY, colors[PApplet.parseInt(random(colors.length))], true, 0.5f, r, 0, 0, "Circle");
    objects[objects.length - 1].currAABB = getAABB(objects[objects.length - 1]);
  }
}

/* 
current benchmark:
100 boxes in the world (20 iterations, 60 fps)
- before caching AABBs: ~75ms per step
- after caching AABBs: ~23ms per step

Notes: 
- 26 Jan: made the Circle and Rectangle Classes, implemented the SAT algorithm for polygons
- 27 Jan: implemented the SAT algorithm for circles and mixed shapes (circle & polygon)
- 27 Jan: added collision resolution for all three cases, fixed some bugs, added movement options
- 28 Jan: added forces and velocities, finished collision resolutions for all cases (added extra movement after collision)
- 28 Jan: added some helper functions
- 29 Jan: added the ability to generate random sizes of boxes and circles, increased stability of engine (added iterations)
- 29 Jan: implemented gravity system
- 29 Jan: restructured the main function, added getAABB and outOfBounds, added manifold class and metric display
- 30 Jan: added recognition for contact points for all classes
- 30 Jan: added rotational inertia for all objects, added line on circle to show its rotation state
- 30 Jan: added two slopes, fixed the finding contact points function (was comparing the contact to the distance (wrong value))
- 31 Jan: optimized the code so now the program runs over 3 times faster using the current benchmark 
(cached the AABBs of every object at the beginning instead of recomputing them every time in the double for loop)
- 1 Feb: Restructured the code, added rotational physics
- 2 Feb: attempted to add friction
- 3 Feb: finished adding friction

https://youtube.com/playlist?list=PLSlpr6o9vURwq3oxVZSimY8iC-cdd3kIs&feature=shared (main source used for this project)

extra note: some aspects are different from the original source to suit my style of coding
*/
class Manifold{ //class used to store contacts between objects
  Shape shapeA;
  Shape shapeB;
  PVector direction;
  float magnitude;
  PVector[] contactPoints;
  PVector contactP2;
  int contactCount;
  
  Manifold(Shape a, Shape b, PVector normal, float mag, PVector[] points, int count){
    shapeA = a;
    shapeB = b;
    direction = new PVector(normal.x, normal.y);
    magnitude = mag;
    contactPoints = points;
    contactCount = count;
  }
}
class Shape{
  PVector center;
  float angle = 0;
  PVector linearVelocity = new PVector(0, 0);
  float angularVelocity = 0;
  PVector force = new PVector(0, 0);
  PVector forceDirection = new PVector(0, 0);
  int currColor;
  boolean isMovable;
  float restitution; //coefficient that determines the elasticity of the collision between two objects
  float mass = 0;
  float invMass = 0;
  float density = 1;
  float r;
  PVector edgePercent = new PVector(1, 0); //edgePercent is only used to draw the line on the circle
  float w, h;
  PVector[] vertices;
  PVector[] transformedVertices;
  String shapeType;
  float rotationalInertia = 0;
  float invRotationalInertia = 0;
  PVector[] currAABB;
  float staticFriction = 0.6f;
  float dynamicFriction = 0.4f;
  
  
  Shape(float x, float y, int c, boolean movable, float re, float radius, float width_, float height_, String type){
    center = new PVector(x, y);
    currColor = c;
    isMovable = movable;
    shapeType = type;
    restitution = re;
    
    if(type == "Circle"){
      r = radius;
      mass = r * r * PI * density;
      rotationalInertia = 1.0f/2.0f * mass * (r * r);
    }else if(type == "Box"){
      w = width_;
      h = height_;
      vertices = new PVector[4];
      vertices[0] = new PVector(x - w/2, y - h/2);
      vertices[1] = new PVector(x + w/2, y - h/2);
      vertices[2] = new PVector(x + w/2, y + h/2);
      vertices[3] = new PVector(x - w/2, y + h/2);
      transformedVertices = new PVector[4];
      transformedVertices[0] = new PVector(x - w/2, y - h/2);
      transformedVertices[1] = new PVector(x + w/2, y - h/2);
      transformedVertices[2] = new PVector(x + w/2, y + h/2);
      transformedVertices[3] = new PVector(x - w/2, y + h/2);
      mass = w * h * density;
      rotationalInertia = 1.0f/12.0f * mass * (h * h + w * w);
    }
        
    if(movable){
      invMass = 1 / mass;
      invRotationalInertia = 1 / rotationalInertia;
    }
  }
  
  public void show(){
    fill(currColor);
    stroke(250);
    //if(isColliding && isMovable){
    //  //fill(red);
    //}
    if(shapeType == "Circle"){
      circle(center.x, center.y, r * 2);
      line(center.x, center.y, center.x + edgePercent.x * r, center.y + edgePercent.y * r);
    }else if(shapeType == "Box"){
      quad(transformedVertices[0].x, transformedVertices[0].y, 
           transformedVertices[1].x, transformedVertices[1].y, 
           transformedVertices[2].x, transformedVertices[2].y, 
           transformedVertices[3].x, transformedVertices[3].y);
    }
    //stroke(0);
    //noFill();
    //rect(currAABB[0].x + (currAABB[1].x - currAABB[0].x)/2, currAABB[0].y + (currAABB[1].y - currAABB[0].y)/2, 
    //     currAABB[1].x - currAABB[0].x, currAABB[1].y - currAABB[0].y);
  }
  
  public void update(){
    center.x += linearVelocity.x;
    if(shapeType == "Box"){
      for(int i = 0; i < vertices.length; i++){
        vertices[i].x += linearVelocity.x;
      }
    }
    center.y += linearVelocity.y;
    if(shapeType == "Box"){
      for(int i = 0; i < vertices.length; i++){
        vertices[i].y += linearVelocity.y;
      }
    }
  }
  
  public void move(float xDisp, float yDisp){
    center.x += xDisp;
    center.y += yDisp;
    if(shapeType == "Box"){
      for(int i = 0; i < vertices.length; i++){
        vertices[i].x += xDisp;
        vertices[i].y += yDisp;
      }
    }
    updateAABB(xDisp, yDisp);
  }
  
  public void turn(float degrees){
    float temp; //temp ensures that the y component is still using the original x component (not the transformed one)
    if(shapeType == "Circle"){
      temp = edgePercent.x * cos(radians(degrees)) - edgePercent.y * sin(radians(degrees));
      edgePercent.y = edgePercent.x * sin(radians(degrees)) + edgePercent.y * cos(radians(degrees));
      edgePercent.x = temp;
    }else if(shapeType == "Box"){
      for(int i = 0; i < vertices.length; i++){
        temp = (vertices[i].x - center.x) * cos(radians(degrees)) - (vertices[i].y - center.y) * sin(radians(degrees)) + center.x;
        vertices[i].y = (vertices[i].x - center.x) * sin(radians(degrees)) + (vertices[i].y - center.y) * cos(radians(degrees)) + center.y;
        vertices[i].x = temp;
      }
    }
  }
  
  public void getTransformedVertices(){
    if(shapeType == "Box"){
      for(int i = 0; i < vertices.length; i++){
        transformedVertices[i].x = (vertices[i].x - center.x) * cos(angle) - (vertices[i].y - center.y) * sin(angle) + center.x;
        transformedVertices[i].y = (vertices[i].x - center.x) * sin(angle) + (vertices[i].y - center.y) * cos(angle) + center.y;
      }
    }
    else if(shapeType == "Circle"){
      edgePercent.x = cos(angle);
      edgePercent.y = sin(angle);
    }
  }
  
  public void addForce(float x, float y){
    force.x += x;
    force.y += y;
  }
  
  public void updateForceVelocityAngle(float time, int iterations){
    //force = mass * acceleration
    //acceleration = force / mass
    
    float updateTime = time / (float) iterations;
    
    if(gravityMode == true){ //gravity is acceleration, so no need to divide by mass again
      linearVelocity.y += gravity * updateTime;
    }
    
    linearVelocity.x += force.x * invMass * updateTime;
    linearVelocity.y += force.y * invMass * updateTime;

    angle += angularVelocity * time;
    
    force.x = 0;
    force.y = 0;
  }
  
  public void updateAABB(float xDisp, float yDisp){
    currAABB[0].x += xDisp;
    currAABB[0].y += yDisp;
    currAABB[1].x += xDisp;
    currAABB[1].y += yDisp;
  }
  
  public void damping(){
    linearVelocity.x *= 0.99f; 
    linearVelocity.y *= 0.99f;
  }
}
public void findPotentialCollisions(){
  //goes through each object
  for(int i = 0; i < objects.length - 1; i++){
    
    //goes through every other object
    for(int j = i + 1; j < objects.length; j++){
      //skips both objects if they are both static
      if(!objects[i].isMovable && !objects[j].isMovable){
        continue;
      }
      //skips if the AABBs of both objects aren't intersecting
      if(!intersectingAABBs(objects[i].currAABB, objects[j].currAABB)){
        continue;
      }
      
      contactPairsList = Arrays.copyOf(contactPairsList, contactPairsList.length + 1);
      contactPairsList[contactPairsList.length - 1] = new int[2];
      contactPairsList[contactPairsList.length - 1][0] = i;
      contactPairsList[contactPairsList.length - 1][1] = j;
    }
  }
}

public void checkPotentialCollisions(){
  Shape objectA;
  Shape objectB;
  for(int i = 0; i < contactPairsList.length; i++){
    objectA = objects[contactPairsList[i][0]];
    objectB = objects[contactPairsList[i][1]];
    //checks for all collision cases (box & box, circle & circle, box & circle)
    if(objectA.shapeType == "Box" && objectB.shapeType == "Box"){
      collisionState = isIntersecting(objectA.transformedVertices, objectB.transformedVertices, objectA.center, objectB.center);

    }else if(objectA.shapeType == "Circle" && objectB.shapeType == "Circle"){
      collisionState = areCirclesIntersecting(objectA.center, objectB.center, objectA.r, objectB.r);

    }else{
      //objectA is the circle, objectB is the box
      if(objectB.shapeType == "Circle"){
        //swaps the objects so the references line up with the next bit of code
        Shape temp = objectB;
        objectB = objectA;
        objectA = temp;
        int temp2 = contactPairsList[i][1];
        contactPairsList[i][1] = contactPairsList[i][0];
        contactPairsList[i][0] = temp2;
      }
      collisionState = isCircleAndPolygonIntersecting(objectA.center, objectA.r, objectB.transformedVertices, objectB.center);
    }
    //checks if a collision has happened
    if(collisionState){
      Manifold contact = handleCollision(contactPairsList[i][0], contactPairsList[i][1]);
      resolveCollisionComplexWithFriction(contact);
    }
  }
}

public Manifold handleCollision(int i, int j){

  //checks if both objects are movable or if one or the other is static (moves both objects out of each other)
  if(!objects[i].isMovable){
    objects[j].move(direction.x * magnitude, direction.y * magnitude);
  }else if(!objects[j].isMovable){
    objects[i].move(-1 * direction.x * magnitude, -1 * direction.y * magnitude);
  }else{
    objects[i].move(-1 * direction.x * magnitude / 2.0f, -1 * direction.y * magnitude / 2.0f);
    objects[j].move(direction.x * magnitude / 2.0f, direction.y * magnitude / 2.0f);
  }
  
  PVector[] pointsAndCount = findContactPoints(objects[i], objects[j]);
  
  return new Manifold(objects[i], objects[j], direction, magnitude, pointsAndCount, pointsAndCount.length);
}

public void resolveCollisionBasic(Manifold contact){
  //unpacks all the variables for use
  Shape shapeA = contact.shapeA;
  Shape shapeB = contact.shapeB;
  PVector currDirection = contact.direction;
  
  //returns early if both shapes are static (no velocities will be applied)
  if(!shapeA.isMovable && !shapeB.isMovable){
    return;
  }
  
  //complex math stuffs
  //equation 1: v1 = v0 + j / m * n;     note: j = impulse, n = normal
  //equation 2: j = -(1 + e) * vAB1 * n / dotProduct(n, n(1/mA + 1/mB));
  //note: vAB1 = relative velocity, e = restitution coefficient
  
  //gets the difference in velocities between both shapes
  PVector relativeVelocity = new PVector(shapeB.linearVelocity.x - shapeA.linearVelocity.x, shapeB.linearVelocity.y - shapeA.linearVelocity.y);
  
  if(dotProduct(relativeVelocity, currDirection) > 0){
    return;
  }
  
  float e = min(shapeA.restitution, shapeB.restitution);
  float j = -(1 + e) * dotProduct(relativeVelocity, currDirection) / (shapeA.invMass + shapeB.invMass);
  PVector impulse = new PVector(j * currDirection.x, j * currDirection.y);
     
  //applies the velocity to shapeA if it's movable
  if(shapeA.isMovable){
    shapeA.linearVelocity.x += -1 * impulse.x * shapeA.invMass;
    shapeA.linearVelocity.y += -1 * impulse.y * shapeA.invMass;
  }
  //applies the velocity to shapeB if it's movable
  if(shapeB.isMovable){
    shapeB.linearVelocity.x += impulse.x * shapeB.invMass;
    shapeB.linearVelocity.y += impulse.y * shapeB.invMass;
  }
}

public void resolveCollisionComplex(Manifold contact){
  Shape shapeA = contact.shapeA;
  Shape shapeB = contact.shapeB;
  PVector currDirection = contact.direction;
  contactPointsArr[0] = contact.contactPoints[0];
  if(contact.contactCount > 1){
    contactPointsArr[1] = contact.contactPoints[1];
  }
  
  PVector ra;
  PVector rb;
  PVector raPerpendicular;
  PVector rbPerpendicular;

  for(int i = 0; i < 2; i++){
    impulseList[i].x = 0;
    impulseList[i].y = 0;
    raList[i].x = 0;
    raList[i].y = 0;
    rbList[i].x = 0;
    rbList[i].y = 0;
  }
  
  PVector impulse;
  
  float e = min(shapeA.restitution, shapeB.restitution);
  
  for(int i = 0; i < contact.contactCount; i++){
    ra = new PVector(contactPointsArr[i].x - shapeA.center.x, contactPointsArr[i].y - shapeA.center.y);
    rb = new PVector(contactPointsArr[i].x - shapeB.center.x, contactPointsArr[i].y - shapeB.center.y);
    
    raList[i] = ra;
    rbList[i] = rb;
    
    raPerpendicular = new PVector(-1 * ra.y, ra.x);
    rbPerpendicular = new PVector(-1 * rb.y, rb.x);

    PVector combinedVelocityA = new PVector(raPerpendicular.x * shapeA.angularVelocity, raPerpendicular.y * shapeA.angularVelocity);
    PVector combinedVelocityB = new PVector(rbPerpendicular.x * shapeB.angularVelocity, rbPerpendicular.y * shapeB.angularVelocity);

    PVector relativeVelocity = new PVector((shapeB.linearVelocity.x + combinedVelocityB.x) - (shapeA.linearVelocity.x + combinedVelocityA.x), 
                                           (shapeB.linearVelocity.y + combinedVelocityB.y) - (shapeA.linearVelocity.y + combinedVelocityA.y));
  
    float raPerpDotN = dotProduct(raPerpendicular, currDirection);
    float rbPerpDotN = dotProduct(rbPerpendicular, currDirection);
    
    float contactVelocityMag = dotProduct(relativeVelocity, currDirection);
    
    if(contactVelocityMag > 0){
      continue;
    }

    float j = -(1 + e) * contactVelocityMag;
    j /= shapeA.invMass + shapeB.invMass + 
         (raPerpDotN * raPerpDotN) * shapeA.invRotationalInertia + 
         (rbPerpDotN * rbPerpDotN) * shapeB.invRotationalInertia;
         
    j /= contact.contactCount;      
         
     impulse = new PVector(j * currDirection.x, j * currDirection.y);
    
    impulseList[i] = impulse; 
  }
  
  for(int i = 0; i < contact.contactCount; i++){
    impulse = impulseList[i];
    ra = raList[i];
    rb = rbList[i];
    
    //applies the velocity to shapeA if it's movable
    if(shapeA.isMovable){
      shapeA.linearVelocity.x += -1 * impulse.x * shapeA.invMass;
      shapeA.linearVelocity.y += -1 * impulse.y * shapeA.invMass;
      
      shapeA.angularVelocity += -1 * crossProduct(ra, impulse) * shapeA.invRotationalInertia;
    }
    //applies the velocity to shapeB if it's movable
    if(shapeB.isMovable){
      shapeB.linearVelocity.x += impulse.x * shapeB.invMass;
      shapeB.linearVelocity.y += impulse.y * shapeB.invMass;
      
      shapeB.angularVelocity += crossProduct(rb, impulse) * shapeB.invRotationalInertia;
    }
  }
}

//doesn't work
public void resolveCollisionComplexWithFriction(Manifold contact){
  Shape shapeA = contact.shapeA;
  Shape shapeB = contact.shapeB;
  PVector currDirection = contact.direction;
  contactPointsArr[0] = contact.contactPoints[0];
  if(contact.contactCount > 1){
    contactPointsArr[1] = contact.contactPoints[1];
  }
    
  PVector ra;
  PVector rb;
  PVector raPerpendicular;
  PVector rbPerpendicular;

  for(int i = 0; i < 2; i++){
    impulseList[i].x = 0;
    impulseList[i].y = 0;
    frictionImpulseList[i].x = 0;
    frictionImpulseList[i].y = 0;
    jList[i] = 0.0f;
    raList[i].x = 0;
    raList[i].y = 0;
    rbList[i].x = 0;
    rbList[i].y = 0;
  }
  
  PVector impulse;
  PVector frictionImpulse;
  
  float e = min(shapeA.restitution, shapeB.restitution);
  
  float staticFrictionConst = (shapeA.staticFriction + shapeB.staticFriction) * 0.5f;
  float dynamicFrictionConst = (shapeA.dynamicFriction + shapeB.dynamicFriction) * 0.5f;
    
  for(int i = 0; i < contact.contactCount; i++){
    ra = new PVector(contactPointsArr[i].x - shapeA.center.x, contactPointsArr[i].y - shapeA.center.y);
    rb = new PVector(contactPointsArr[i].x - shapeB.center.x, contactPointsArr[i].y - shapeB.center.y);
    
    raList[i] = ra;
    rbList[i] = rb;
    
    raPerpendicular = new PVector(-1 * ra.y, ra.x);
    rbPerpendicular = new PVector(-1 * rb.y, rb.x);
    
    PVector combinedVelocityA = new PVector(raPerpendicular.x * shapeA.angularVelocity, raPerpendicular.y * shapeA.angularVelocity);
    PVector combinedVelocityB = new PVector(rbPerpendicular.x * shapeB.angularVelocity, rbPerpendicular.y * shapeB.angularVelocity);

    PVector relativeVelocity = new PVector((shapeB.linearVelocity.x + combinedVelocityB.x) - (shapeA.linearVelocity.x + combinedVelocityA.x), 
                                           (shapeB.linearVelocity.y + combinedVelocityB.y) - (shapeA.linearVelocity.y + combinedVelocityA.y));
  
    float raPerpDotN = dotProduct(raPerpendicular, currDirection);
    float rbPerpDotN = dotProduct(rbPerpendicular, currDirection);
    
    float contactVelocityMag = dotProduct(relativeVelocity, currDirection);
        
    if(contactVelocityMag > 0){
      continue;
    }

    float j = -(1 + e) * contactVelocityMag;
    j /= shapeA.invMass + shapeB.invMass + 
         (raPerpDotN * raPerpDotN) * shapeA.invRotationalInertia + 
         (rbPerpDotN * rbPerpDotN) * shapeB.invRotationalInertia;
         
    j /= contact.contactCount;   
    
    jList[i] = j;
         
    impulse = new PVector(j * currDirection.x, j * currDirection.y);
    impulseList[i] = impulse; 
  }
  
  for(int i = 0; i < contact.contactCount; i++){
    impulse = impulseList[i];
    ra = raList[i];
    rb = rbList[i];
    
    //applies the velocity to shapeA if it's movable
    if(shapeA.isMovable){
      shapeA.linearVelocity.x += -1 * impulse.x * shapeA.invMass;
      shapeA.linearVelocity.y += -1 * impulse.y * shapeA.invMass;
      
      shapeA.angularVelocity += -1 * crossProduct(ra, impulse) * shapeA.invRotationalInertia;
    }
    //applies the velocity to shapeB if it's movable
    if(shapeB.isMovable){
      shapeB.linearVelocity.x += impulse.x * shapeB.invMass;
      shapeB.linearVelocity.y += impulse.y * shapeB.invMass;
      
      shapeB.angularVelocity += crossProduct(rb, impulse) * shapeB.invRotationalInertia;
    }
  }

  //calculates friction
  for(int i = 0; i < contact.contactCount; i++){
    ra = new PVector(contactPointsArr[i].x - shapeA.center.x, contactPointsArr[i].y - shapeA.center.y);
    rb = new PVector(contactPointsArr[i].x - shapeB.center.x, contactPointsArr[i].y - shapeB.center.y);
    
    raList[i] = ra;
    rbList[i] = rb;
    
    raPerpendicular = new PVector(-1 * ra.y, ra.x);
    rbPerpendicular = new PVector(-1 * rb.y, rb.x);
    
    PVector combinedVelocityA = new PVector(raPerpendicular.x * shapeA.angularVelocity, raPerpendicular.y * shapeA.angularVelocity);
    PVector combinedVelocityB = new PVector(rbPerpendicular.x * shapeB.angularVelocity, rbPerpendicular.y * shapeB.angularVelocity);

    PVector relativeVelocity = new PVector((shapeB.linearVelocity.x + combinedVelocityB.x) - (shapeA.linearVelocity.x + combinedVelocityA.x), 
                                           (shapeB.linearVelocity.y + combinedVelocityB.y) - (shapeA.linearVelocity.y + combinedVelocityA.y));
    
    float projectedVelocity = dotProduct(relativeVelocity, currDirection);
    
    PVector tangent = new PVector(relativeVelocity.x - projectedVelocity * currDirection.x,
                                  relativeVelocity.y - projectedVelocity * currDirection.y);
                                                                                            
    if(almostEqualVectors(tangent, new PVector(0, 0))){
      continue;
    }else{
      float tangentLen = lengthOfVector(tangent);
      tangent.x /= tangentLen;
      tangent.y /= tangentLen;
    }
        
    float raPerpDotT = dotProduct(raPerpendicular, tangent);
    float rbPerpDotT = dotProduct(rbPerpendicular, tangent);

    float contactVelocityMagT = dotProduct(relativeVelocity, tangent);

    float jT = -1 * contactVelocityMagT;
    jT /= shapeA.invMass + shapeB.invMass + 
         (raPerpDotT * raPerpDotT) * shapeA.invRotationalInertia + 
         (rbPerpDotT * rbPerpDotT) * shapeB.invRotationalInertia;
         
    jT /= contact.contactCount;
    
    float j = jList[i];

    //Coulomb's Law
    if(abs(jT) <= j * staticFrictionConst){
      frictionImpulse = new PVector(jT * tangent.x, jT * tangent.y);
    }else{
      frictionImpulse = new PVector(abs(jT)/jT * j * tangent.x * dynamicFrictionConst, abs(jT)/jT * j * tangent.y * dynamicFrictionConst);
    }
    
    frictionImpulseList[i] = frictionImpulse; 
  }
    

  for(int i = 0; i < contact.contactCount; i++){
    frictionImpulse = frictionImpulseList[i];
    ra = raList[i];
    rb = rbList[i];
    //applies the velocity to shapeA if it's movable
    if(shapeA.isMovable){
      shapeA.linearVelocity.x += -1 * frictionImpulse.x * shapeA.invMass;
      shapeA.linearVelocity.y += -1 * frictionImpulse.y * shapeA.invMass;
      
      shapeA.angularVelocity += -1 * crossProduct(ra, frictionImpulse) * shapeA.invRotationalInertia;
    }
        
    //applies the velocity to shapeB if it's movable
    if(shapeB.isMovable){
      shapeB.linearVelocity.x += frictionImpulse.x * shapeB.invMass;
      shapeB.linearVelocity.y += frictionImpulse.y * shapeB.invMass;
      
      shapeB.angularVelocity += crossProduct(rb, frictionImpulse) * shapeB.invRotationalInertia;
    }
  }
}
public PVector[] findContactPoints(Shape shapeA, Shape shapeB){
  PVector[] res = new PVector[0];
  
  //checks for the shape type of both shapes before doing the calculations
  if(shapeA.shapeType == "Box" && shapeB.shapeType == "Box"){
    PVector[] temp = findContactPointBoxes(shapeA.transformedVertices, shapeB.transformedVertices);
    res = Arrays.copyOf(res, temp.length);
    for(int i = 0; i < temp.length; i++){
      res[i] = temp[i];
    }
  }else if(shapeA.shapeType == "Circle" && shapeB.shapeType == "Circle"){
    res = Arrays.copyOf(res, res.length + 1);
    res[res.length - 1] = findContactPointCircles(shapeA.center, shapeA.r, shapeB.center);
  }else{
    if(shapeA.shapeType == "Circle"){
      res = Arrays.copyOf(res, res.length + 1);
      res[res.length - 1] = findContactPointCircleBox(shapeA.center, shapeB.transformedVertices);
    }else if(shapeB.shapeType == "Circle"){
      res = Arrays.copyOf(res, res.length + 1);
      res[res.length - 1] = findContactPointCircleBox(shapeB.center, shapeA.transformedVertices);
    }
  }
  return res;
}

public PVector findContactPointCircles(PVector centerA, float radiusA, PVector centerB){
  PVector contactPoint = new PVector(0, 0);
  //finds the normalized direction vector between both centers
  PVector aToBDist = new PVector(centerB.x - centerA.x, centerB.y - centerA.y);
  float totalLength = lengthOfVector(aToBDist);
  PVector dir = new PVector(aToBDist.x / totalLength, aToBDist.y / totalLength);
  //multiplies it by the radius of shape A (because the vector points from A to B) to get the contact point
  contactPoint.x = centerA.x + dir.x * radiusA;
  contactPoint.y = centerA.y + dir.y * radiusA;
  
  return contactPoint;
}

public PVector findContactPointCircleBox(PVector centerA, PVector[] verticesB){
  PVector contactPoint = new PVector(0, 0);
  float minDistSq = pow(2, 31) - 1;
  //goes through each vertex
  for(int i = 0; i < verticesB.length; i++){
    PVector vertexA = verticesB[i];
    PVector vertexB = verticesB[(i + 1) % verticesB.length];
    //finids the distance from each line of the box to the center of the circle
    PVector[] contactAndDist = pointSegmentDistance(centerA, vertexA, vertexB);
    float distSq = lengthOfVectorSquared(contactAndDist[1]);
    //updates the values if necessary
    if(distSq < minDistSq){
      minDistSq = distSq;
      contactPoint = contactAndDist[0];
    }
  }
  return contactPoint;
}

public PVector[] pointSegmentDistance(PVector p, PVector a, PVector b){
  //makes two vectors using the three points given (p = point of interest on a shape, a & b are the two vertices of the other shape)
  PVector ab = new PVector(b.x - a.x, b.y - a.y);
  PVector ap = new PVector(p.x - a.x, p.y - a.y);
  PVector contact;
  PVector distances;
  //gets the dot product between ap and ab then "normalizes" it using ab (without the square root)
  float projection = dotProduct(ap, ab);
  float lenSquared = lengthOfVectorSquared(ab);
  float d = projection / lenSquared;
  
  if(d <= 0){  //ab points the opposite direction of ap
    contact = a;
  }else if(d >= 1){ //ab and ap point to the same direction
    contact = b;
  }else{ //somewhere in between
    contact = new PVector(a.x + ab.x * d, a.y + ab.y * d); //finds the middle ground between both points using point A as the reference
  }
  //gets the shortest distance between the contact point and the line
  distances = new PVector(p.x - contact.x, p.y - contact.y);
  
  PVector[] res = {contact, distances};
  
  return res;
}

public PVector[] findContactPointBoxes(PVector[] verticesA, PVector[] verticesB){
  PVector contact1 = new PVector(pow(2, 31) - 1, pow(2, 31) - 1);
  PVector contact2 = new PVector(pow(2, 31) - 1, pow(2, 31) - 1);
  PVector point = new PVector(0, 0);
  float minDistSq = pow(2, 31) - 1;
  //loops through all vertices of shape A
  for(int i = 0; i < verticesA.length; i++){
    point = verticesA[i];
    //loops through all vertices of shape B
    for(int j = 0; j < verticesB.length; j++){
      PVector va = verticesB[j];
      PVector vb = verticesB[(j + 1) % verticesB.length];
      //checks for the distance between line B and point A
      PVector[] contactAndDist = pointSegmentDistance(point, va, vb);
      float distSq = lengthOfVectorSquared(contactAndDist[1]);
      //checks if the distance is almost equal to the current minimum
      if(almostEqual(distSq, minDistSq)){
        //checks if the vectors aren't the same
        if(!almostEqualVectors(contactAndDist[0], contact1)){
          contact2 = contactAndDist[0];
        }
      }else if(distSq < minDistSq){
        minDistSq = distSq;
        contact1 = contactAndDist[0];
      }
    }
  }
  //loops through all the vertices of B
  for(int i = 0; i < verticesB.length; i++){
    point = verticesB[i];
    //loops through all the vertices of A
    for(int j = 0; j < verticesA.length; j++){
      PVector va = verticesA[j];
      PVector vb = verticesA[(j + 1) % verticesA.length];
      //finds the distance between line A and point B
      PVector[] contactAndDist = pointSegmentDistance(point, va, vb);
      float distSq = lengthOfVectorSquared(contactAndDist[1]);
      //checks if the distance is almost equal to the current minimum
      if(almostEqual(distSq, minDistSq)){
        //checks if the vectors aren't the same
        if(!almostEqualVectors(contactAndDist[0], contact1)){
          contact2 = contactAndDist[0];
        }
      }else if(distSq < minDistSq){
        minDistSq = distSq;
        contact1 = contactAndDist[0];
      }
    }
  }
  PVector[] res = {};
  //initializes res according to the number of contact points found
  if(contact2.x != pow(2, 31) - 1 && contact2.y != pow(2, 31) - 1){
    res = new PVector[2];
    res[0] = contact1;
    res[1] = contact2;
  }else if(contact1.x != pow(2, 31) - 1 && contact1.y != pow(2, 31) - 1){
    res = new PVector[1];
    res[0] = contact1;
  }
  return res;
}

public boolean almostEqual(float a, float b){
  float threshold = 0.005f;
  return abs(a - b) < threshold;
}

public boolean almostEqualVectors(PVector a, PVector b){
  float threshold = 0.005f;
  return (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y) < threshold * threshold;
}
public boolean isCircleAndPolygonIntersecting(PVector centerCircle, float radius, PVector[] vertices, PVector centerPolygon){
  //resets the direction and magnitude for comparisons
  direction.x = 0;
  direction.y = 0;
  magnitude = pow(2, 31) - 1;
  tangent.x = 0;
  tangent.y = 0;
  normal.x = 0;
  normal.y = 0;
  float[] projectedPolygon;
  float[] projectedCircle;
  
  for(int i = 0; i < vertices.length; i++){
    //the vectors will be cycled clockwise
    tangent.x = vertices[(i + 1) % vertices.length].x - vertices[i].x; 
    tangent.y = vertices[(i + 1) % vertices.length].y - vertices[i].y;
    //M_tangent * M_normal = -1
    normal.x = -1 * tangent.y;
    normal.y = tangent.x;
    
    float normalLength = lengthOfVector(normal);
    //normalizes the axis for accurate comparisons
    normal.x /= normalLength;
    normal.y /= normalLength;
    
    //finds the maximum and minimum values after projection to the axis 
    //(moving the shortest distance from point to axis) for both sets of vertices
    projectedPolygon = projectToAxis(vertices, normal);
    projectedCircle = projectCircleToAxis(centerCircle, radius, normal);
    //checks if the minimum of either value is greater than the maximum of the other (meaning no intersection)
    if(projectedPolygon[0] >= projectedCircle[1] || projectedCircle[0] >= projectedPolygon[1]){
      return false;
    }
    //gets the magnitude of the current distance to move if there is no gap
    float axisDepth = min(projectedCircle[1] - projectedPolygon[0], projectedPolygon[1] - projectedCircle[0]);
    //checks if there is a new shortest magnitude
    if(axisDepth < magnitude){
      //updates the direction of the normal and the magnitude
      direction.x = normal.x;
      direction.y = normal.y;
      magnitude = axisDepth;
    }
  }
  //finds the closest point of the polygon to the circle
  PVector closestPoint = vertices[closestVertexToCircle(centerCircle, vertices)];
  //gets the axis that goes through both the circle's center and the closest point
  normal.x = closestPoint.x - centerCircle.x;
  normal.y = closestPoint.y - centerCircle.y;
  
  float axisLength = lengthOfVector(normal);
  //normalizes the axis for accurate comparisons
  normal.x /= axisLength;
  normal.y /= axisLength;
  
  //finds the maximum and minimum values after projection to the axis 
  //(moving the shortest distance from point to axis) for both sets of vertices
  projectedPolygon = projectToAxis(vertices, normal);
  projectedCircle = projectCircleToAxis(centerCircle, radius, normal);
  //checks if the minimum of either value is greater than the maximum of the other (meaning no intersection)
  if(projectedPolygon[0] >= projectedCircle[1] || projectedCircle[0] >= projectedPolygon[1]){
    return false;
  }
  //gets the magnitude of the current distance to move if there is no gap
  float axisDepth = min(projectedCircle[1] - projectedPolygon[0], projectedPolygon[1] - projectedCircle[0]);
  //checks if there is a new shortest magnitude
  if(axisDepth < magnitude){
    //updates the direction of the normal and the magnitude
    direction.x = normal.x;
    direction.y = normal.y;
    magnitude = axisDepth;
  }
  
  //gets the direction between the centers of both shapes (polygon to circle) and  
  //checks if the current direction is pointing the same way as the intended normalDirection
  if(dotProductFloats(centerPolygon.x - centerCircle.x, centerPolygon.y - centerCircle.y, direction.x, direction.y) < 0){
    direction.x *= -1;
    direction.y *= -1;
  }
  return true;
}

public int closestVertexToCircle(PVector center, PVector[] vertices){
  int res = -1;
  float minDistance = pow(2, 31) - 1;
  float currDistance = 0;
  //basically checks if the distance between the current vertex of the point is closer to the circle's center 
  //than the current closest vertex
  for(int i = 0; i < vertices.length; i++){
    //no need to do the square root, the value is only used for comparisons, not calculations
    currDistance = lengthSquared(vertices[i].x - center.x, vertices[i].y - center.y);
    if(currDistance < minDistance){
      minDistance = currDistance;
      res = i;
    }
  }
  return res;
}

public float[] projectCircleToAxis(PVector center, float radius, PVector axis){
  //gets the scalar length of the axis from the origin
  float lenAxis = lengthOfVector(axis);
  //direction normalizes the axis
  PVector directionAndRadius = new PVector(radius * (axis.x / lenAxis), radius * (axis.y / lenAxis));
  //gets the two max and min points of the circle (min being the left-most and top-most, max being the right-most and bottom-most) and
  //gets the dot product of max and min values according to the axis (projects both points to the axis without normalization)
  float min = dotProductFloats(center.x - directionAndRadius.x, center.y - directionAndRadius.y, axis.x, axis.y);
  float max = dotProductFloats(center.x + directionAndRadius.x, center.y + directionAndRadius.y, axis.x, axis.y);
  //checks if min is actually greater than max
  if(min > max){
    float temp = min;
    min = max;
    max = temp;
  }
  float[] res = {min, max};

  return res;
}


public boolean areCirclesIntersecting(PVector centerA, PVector centerB, float radiusA, float radiusB){
  //gets the x and y distance between both centers
  float distanceX = centerA.x - centerB.x;
  float distanceY = centerA.y - centerB.y;
  //uses Pythagorean theorem (without square root to reduce computation time) 
  //to compare the current distance with the sum of the radii
  if(distanceX * distanceX + distanceY * distanceY >= (radiusA + radiusB) * (radiusA + radiusB)){
    return false;
  } 
  //performs the square root after the sum of the squares (case where there is collision)
  float totalDistance = pow(distanceX * distanceX + distanceY * distanceY, 0.5f);
  //gets the direction and magnitude of the collision to resolve
  direction.x = (centerB.x - centerA.x) / totalDistance;
  direction.y = (centerB.y - centerA.y) / totalDistance;
  magnitude = (radiusA + radiusB) - totalDistance;
  
  return true;
}

public boolean isIntersecting(PVector[] verticesA, PVector[] verticesB, PVector centerA, PVector centerB){
  //resets the direction of the normal and the magnitude
  direction.x = 0;
  direction.y = 0;
  magnitude = pow(2, 31) - 1;
  tangent.x = 0;
  tangent.y = 0;
  normal.x = 0;
  normal.y = 0;
  float[] projectedA;
  float[] projectedB;
  
  //goes through the vertices of the first shape
  for(int i = 0; i < verticesA.length; i++){
    //the vectors will be cycled clockwise
    //M_tangent * M_normal = -1
    tangent.x = verticesA[(i + 1) % verticesA.length].x - verticesA[i].x;
    tangent.y = verticesA[(i + 1) % verticesA.length].y - verticesA[i].y;
    normal.x = -1 * tangent.y;
    normal.y = tangent.x;
    
    float normalLength = lengthOfVector(normal);
    //normalizes the axis for accurate comparisons
    normal.x /= normalLength;
    normal.y /= normalLength;
    
    //finds the maximum and minimum values after projection to the axis 
    //(moving the shortest distance from point to axis) for both sets of vertices
    projectedA = projectToAxis(verticesA, normal);
    projectedB = projectToAxis(verticesB, normal);
    //checks if the minimum of either value is greater than the maximum of the other (meaning no intersection)
    if(projectedA[0] >= projectedB[1] || projectedB[0] >= projectedA[1]){
      return false;
    }

    //gets the smallest distance between both shapes
    float axisDepth = min(projectedB[1] - projectedA[0], projectedA[1] - projectedB[0]);
    //checks if there is a new shortest distance between both shapes
    if(axisDepth < magnitude){
      //updates the direction of the normal and the magnitude
      direction.x = normal.x;
      direction.y = normal.y;
      magnitude = axisDepth;
    }
  }
  
  //goes through the vertices of the second shape
  for(int i = 0; i < verticesB.length; i++){
    //the vectors will be cycled clockwise
    //M_tangent * M_normal = -1
    tangent.x = verticesB[(i + 1) % verticesB.length].x - verticesB[i].x;
    tangent.y = verticesB[(i + 1) % verticesB.length].y - verticesB[i].y;
    normal.x = -1 * tangent.y;
    normal.y = tangent.x;
    
    float normalLength = lengthOfVector(normal);
    //normalizes the axis for accurate comparisons
    normal.x /= normalLength;
    normal.y /= normalLength;

    //finds the maximum and minimum values after projection to the axis 
    //(moving the shortest distance from point to axis) for both sets of vertices
    projectedA = projectToAxis(verticesA, normal);
    projectedB = projectToAxis(verticesB, normal);
    //checks if the minimum of either value is greater than the maximum of the other (meaning no intersection)
    if(projectedA[0] >= projectedB[1] || projectedB[0] >= projectedA[1]){
      return false;
    }
    //gets the smallest distance between both shapes
    float axisDepth = min(projectedB[1] - projectedA[0], projectedA[1] - projectedB[0]);
    //checks if there is a new shortest distance between both shapes
    if(axisDepth < magnitude){
      //updates the direction of the normal and the magnitude
      direction.x = normal.x;
      direction.y = normal.y;
      magnitude = axisDepth;
    }
  }
  
  //gets the direction between the centers of both shapes (from B to A) and
  //checks if the current direction is pointing the same way as the intended normalDirection
  if(dotProductFloats(centerB.x - centerA.x, centerB.y - centerA.y, direction.x, direction.y) < 0){
    direction.x *= -1;
    direction.y *= -1;
  }
  //case where no gaps are found (there is an intersection)
  return true;
}

public float[] projectToAxis(PVector[] vertices, PVector axis){
  //[0] = min (starts with the maximum value), and [1] = max (starts with the minimum value)
  float[] res = {pow(2, 31) - 1, -1 * pow(2, 31)};

  for(int i = 0; i < vertices.length; i++){
    //finds the dot product of the axis and the current point (vertex)
    //this basically translates the point to the axis in the shortest distance possible (I still don't fully understand it)*
    float projection = dotProduct(vertices[i], axis);
    //replaces the min and maximum values if either condition is true
    res[0] = (projection < res[0]) ? projection : res[0];
    res[1] = (projection > res[1]) ? projection : res[1];
  }
  return res;
}

/*
So, it basically calculates the width of the line (distance) 
from the origin to a specific point after being projected along the axis.
It then basically reduces into the same algorithm used for checking AABBs (Axis-Aligned Boundary Boxes) 
or straightened rectangles, but after a rotation operation has been done. 

AABB check: 
//L2 < R1 and L1 < R2 and B2 < T1 and B1 < T2

The whole algorithm takes advantage of this fact and applies it to all of the faces' normals 
(gradients perpendicular to the surface) as it eliminates the need to calculate angles. 
It then repeats this process for the other polygon to thoroughly check 
if there are any gaps (no intersection) or not (yes intersection).
*/


  public void settings() { size(1000, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Physics_Engine" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
